### параграф 64
### Ответы на вопросы

1. Что такое сортировка?
   Сортировка — это процесс упорядочивания элементов в массиве или списке по заданному критерию, например, по возрастанию или убыванию.

2. На какой идее основан метод пузырька? Метод выбора?
   - Метод пузырька основан на последовательном сравнении соседних элементов и их перестановке, если они находятся в неправильном порядке. Этот процесс повторяется, пока весь массив не будет отсортирован.
   - Метод выбора основывается на нахождении минимального (или максимального) элемента из неотсортированной части массива и его перемещении в отсортированную часть.

3. Объясните, зачем нужен вложенный цикл в описанных методах сортировки.
   Вложенный цикл нужен для того, чтобы пройтись по всем элементам массива. В методе пузырька внешний цикл отвечает за проход по массиву, а вложенный цикл сравнивает и переставляет элементы. В методе выбора внешний цикл выбирает элемент для сортировки, а внутренний ищет минимальный/максимальный элемент.

4. Сравните на примере метод пузырька и метод выбора. Какой из них требует меньше перестановок?
   В методе пузырька происходит много перестановок, особенно при сортировке неотсортированного массива. Метод выбора выполняет меньшее количество перестановок, так как каждый раз он перемещает только один элемент в отсортированную часть.

5. Расскажите про основные идеи метода «быстрой сортировки».
   Быстрая сортировка основана на принципе «разделяй и властвуй». Идея заключается в выборе опорного элемента, разделении массива на две части (меньшие и большие относительно опорного) и рекурсивной сортировке этих частей.

6. Как нужно изменить приведённые в параграфе алгоритмы, чтобы элементы массива были отсортированы по убыванию?
   Чтобы отсортировать по убыванию, нужно изменить условие сравнения в оба метода: при сравнении элементов их нужно располагать в порядке, где больший элемент стоит перед меньшим.

7. Как вы думаете, можно ли использовать метод «быстрой сортировки» для нечисловых данных, например для символьных строк?
   Да, метод быстрой сортировки можно применять к символьным строкам. Сравнения будут основываться на сортировке по алфавиту или кодировке символов.

8. От чего зависит скорость «быстрой сортировки»? Какой самый лучший и самый худший случай?
   Скорость зависит от выбора опорного элемента. Лучший случай возникает при равномерном распределении элементов (например, уже отсортированные данные), а худший — при массиве, отсортированном в обратном порядке, особенно если опорный элемент всегда выбирается крайним.

9. Как вы думаете, может ли метод «быстрой сортировки» работать дольше, чем метод выбора (или другой «простой» метод)? Если да, то при каких условиях?
   Да, метод быстрой сортировки может работать дольше, чем метод выбора, если данные уже отсортированы в порядке, противоположном вектору опорного элемента (то есть при плохом выборе опорного элемента).

### 1. Программа, которая отсортирует массив и найдет количество уникальных чисел

def unique_count(arr):
    unique_numbers = set(arr)
    sorted_numbers = sorted(arr)
    return sorted_numbers, len(unique_numbers)

# Пример использования
arr = [3, 5, 2, 3, 5, 8, 2]
sorted_arr, unique_count_result = unique_count(arr)
print("Отсортированный массив:", sorted_arr)
print("Количество уникальных чисел:", unique_count_result)


### 2. Сортировка методом камня

def stone_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]  # перестановка
    return arr

# Пример использования
arr = [3, 5, 1, 4, 2]
sorted_arr = stone_sort(arr)
print("Отсортированный массив методом камня:", sorted_arr)


### 3. Вариант пузырьковой сортировки без перестановок

def optimized_bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:  # Если не было перестановок, выходим из цикла
            break
    return arr

# Пример использования
arr = [5, 1, 4, 2, 8]
sorted_arr = optimized_bubble_sort(arr)
print("Отсортированный массив (оптимизированный пузырьком):", sorted_arr)


### 4. Сортировка массива по последней цифре

def sort_by_last_digit(arr):
    sorted_arr = sorted(arr, key=lambda x: x % 10)
    return sorted_arr

# Пример использования
arr = [23, 43, 12, 33, 52]
sorted_arr = sort_by_last_digit(arr)
print("Отсортированный массив по последней цифре:", sorted_arr)


### 5. Сортировка по убыванию суммы цифр чисел

def sum_of_digits(n):
    return sum(int(digit) for digit in str(n))

def sort_by_sum_of_digits(arr):
    sorted_arr = sorted(arr, key=sum_of_digits, reverse=True)
    return sorted_arr

# Пример использования
arr = [23, 45, 67, 89, 12]
sorted_arr = sort_by_sum_of_digits(arr)
print("Отсортированный массив по убыванию суммы цифр:", sorted_arr)


### 6. Сортировка первой половины массива по возрастанию, второй - по убыванию

def sort_half(arr):
    mid = len(arr) // 2
    first_half = sorted(arr[:mid])
    second_half = sorted(arr[mid:], reverse=True)
    return first_half + second_half

# Пример использования
arr = [3, 5, 1, 4, 2, 6, 9, 8, 7]
sorted_arr = sort_half(arr)
print("Отсортированный массив (первая половина - возрастание, вторая - убывание):", sorted_arr)


### 7. Нахождение максимального элемента, встречающегося несколько раз после сортировки

def max_duplicate(arr):
    sorted_arr = sorted(arr)
    duplicates = {}
    
    for num in sorted_arr:
        if num in duplicates:
            duplicates[num] += 1
        else:
            duplicates[num] = 1
            
    max_num = None
    for num, count in duplicates.items():
        if count > 1:
            if max_num is None or num > max_num:
                max_num = num
            
    return max_num

# Пример использования
arr = [1, 2, 3, 2, 4, 1, 5, 3]
max_duplicate_num = max_duplicate(arr)
print("Максимальный элемент, встречающийся несколько раз:", max_duplicate_num)

### параграф 65
### Ответы на вопросы

1. Почему приведённый в параграфе алгоритм поиска называется двоичным?
   Двоичный поиск называется так потому, что на каждом шаге он делит массив на две равные части. Алгоритм сравнивает искомое значение со значением, находящимся в середине массива, и на следующей итерации продолжает поиск только в одной из получившихся частей, в зависимости от того, больше или меньше искомое значение. Это делает алгоритм очень эффективным для отсортированных массивов, так как количество элементов, которые нужно проверить, уменьшается в два раза с каждой итерацией.

2. Как можно примерно подсчитать количество шагов при двоичном поиске?
   При двоичном поиске количество шагов (итераций) можно выразить с помощью логарифма. Для массива из n элементов, максимальное количество шагов можно подсчитать по формуле log2(n). Например, для 32 элементов это будет равно log2(32) = 5. Это значит, что максимальное количество сравнений, необходимое для нахождения элемента, составляет 5. Более формально, при каждом делении массива мы уменьшаем количество оставшихся элементов в два раза.

### Подготовка сообщений

а) «Двоичный поиск в нашей жизни»
   Двоичный поиск — это метод, который находит применение не только в программировании, но и в повседневной жизни. Например, когда мы ищем нужную информацию в большом каталоге или списке, мы можем быстро сузить поиск, используя метод, схожий с двоичным поиском: мы сначала читаем центральную часть, а затем решаем, в какую часть идти дальше — в верхнюю или нижнюю, в зависимости от нас интересующей записи. Это аналогично тому, как профессиональные библиотекари используют классификации для быстрой навигации по огромным библиотечным системам. Таким образом, двоичный поиск облегчает наш процесс принятия решений и экономит время.

б) «Линейный и двоичный поиск: достоинства и недостатки»
   Линейный и двоичный поиск — это два различных подхода к поиску данных. Линейный поиск работает последовательно, проверяя каждый элемент массива, и подходит для неотсортированных массивов. Его основной недостаток — плохая эффективность при больших объемах данных, поскольку в худшем случае он требует n шагов для поиска элемента. 

   Двоичный поиск, в отличие от линейного, требует предварительной сортировки массива, но значительно более эффективен, особенно в больших массивах, поскольку его сложность составляет O(log n). Тем не менее, его применение ограничено только отсортированными массивами. 

   В итоге, выбор между линейным и двоичным поиском зависит от структуры данных: если массив не отсортирован, удобнее использовать линейный поиск, в противном случае — двоичный, что сведет время поиска к минимуму.

### Задачи

#### 1. Программа, сортирующая массив по убыванию и ищущая значения, равные заданному числу

def sort_and_find(arr, target):
    sorted_arr = sorted(arr, reverse=True)
    found_indices = [i for i, x in enumerate(sorted_arr) if x == target]
    return sorted_arr, found_indices

# Пример использования
arr = [3, 5, 1, 4, 2, 5, 3]
target = 3
sorted_arr, indices = sort_and_find(arr, target)
print("Отсортированный массив по убыванию:", sorted_arr)
print("Индексы найденных значений", target, ":", indices)


#### 2. Программа для подсчета среднего числа шагов при двоичном поиске

import random
import math

def binary_search(arr, target):
    low, high, steps = 0, len(arr) - 1, 0
    while low <= high:
        mid = (low + high) // 2
        steps += 1
        if arr[mid] == target:
            return steps
        elif arr[mid] < target:
            high = mid - 1
        else:
            low = mid + 1
    return steps  # Вернём количество шагов (не найдено)

def average_binary_search_steps(array_size, search_range, num_trials):
    total_steps = 0
    for _ in range(num_trials):
        target = random.randint(0, search_range)
        arr = sorted(random.sample(range(search_range + 1), array_size))  # Генерация отсортированного массива
        steps = binary_search(arr, target)
        total_steps += steps
    return total_steps / num_trials

# Пример использования
array_size = 32
search_range = 100
num_trials = 1000
average_steps = average_binary_search_steps(array_size, search_range, num_trials)
print("Среднее число шагов при двоичном поиске:", average_steps)
